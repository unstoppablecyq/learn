# Java

## 编程基础

#### 第1章 内容介绍

##### 1.1-1.6 就业方向、开发场景、应用领域。

#### 第2章 概述

##### 2.1

​	**程序**：有序指令的集合

##### 2.2 诞生

​	最早的版本-2005

##### 2.3 技术体系平台

Java SE

Java EE

Java ME

##### 2.4 特点

- 面向对象的(oop)
- 健壮的（强类型机制、异常处理、垃圾的自动收集）
- 跨平台的(一个编译好的.class文件可以在多个系统下运行)
- 解释型的(解释性语言 : javascript , PHP , java;编译姓语言 : c / c++. 解释性语言编译后不能直接被语言执行,需要解释器来执行;编译性语言编译后的代码可以直接被机器执行.

##### 2.5 开发工具

editplus、notepad++

Sublime Text

IDEA

eclipse

##### 2.6 运行机制与运行过程

###### 2.6.1 Java-跨平台性

###### 2.6.2 核心机制-Java虚拟机

- ​	 JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器，包含在JDK中.
-  	对于不同的平台，有不同的虚拟机.
- ​	Java虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行” .

##### 2.7 JDK , JRE

​	JDK ( Java Development Kit    Java开发工具包 ) = JDK = JRE + java的开发工具

​	JRE ( Java Runtime Environment     Java运行环境 ) = JVM + Java的核心类库

##### 2.8--2.10 下载、安装&配置环境变量

///////////////////////

##### 2.11 入门

Java代码编写到Hello.java , 然后使用javac命令编译生成.class文件，用java命令运行class文件

**注意事项：**

​	区分大小写，不要漏了”;“，括号成对[],{}。

​	一个源文件中最多只有一个public类，其他类个数不限

​	如果源文件包含一个public类，则文件名必须按该类名命名

​	也可以将main方法卸载非public类中，然后指定运行非public类，这样入口方法就是非public的main方法。

##### 	2.15 Java转义字符

- 常用的转义字符

  \t : 制表位

  \n ： 换行符

  \ \  ： 一个\

  \ " : 一个"

  \ ' ： 一个'

  \r : 一个回车

##### 2.16 易错点（语法错误，理解编译器报告的错误信息）

- ​	找不到文件：源文件名不存在或者写错，或者路径错误
- ​	主类名和文件名不一致：声名为public的主类应与文件名一直，否则编译失败
- ​	缺少分号：编译失败，报错中定位错误行去改错

​	

##### 2.17 注释(comment)-良好的编程习惯

​	提高可读性，先将思路通过注释整理出来，再用代码去体现

- 被注释的文字不会被JVM解释执行
- 多行注释里面不允许有多行注释嵌套

单行注释：//注释文字

多行注释/*  注释文字  */

文档注释/**    */ 		：javadoc -d 文件夹名 -xx -yy abc.java		(xx,yy可以包含author、version等等内容)

##### 2.18 代码规范

- 对于类、方法的注释，要以javadoc的方式来写
- 非java doc的注释，往往给维护者看，告诉读者为什么这么写、如何修改、注意事项 
- 运算符和 = 两边习惯加一个空格，运用tab实现缩进
- 源文件使用utf-8编码
- 行宽度不要超过80字符
- 代码编写**次行风格**（换行再用大括号）和**行尾风格**（更为推荐!!大括号在行尾）-看个人习惯，两种方式都可以。

##### 2.19 DOS命令

基本原理：

​	cmd指令------回车------>Dos系统（接受、解析、执行指令）----->作用于windows文件系统

**相对路径&绝对路径**

相对路径：从当前目录开始定位--> ..\ ..\abc\123.txt

绝对路径：从顶级目录开始定位-->c:\abx\123.txt

**常用的dos命令：**

- 查看当前目录是有什么内容 - dir : d:\abc\test200
- 切换到其他盘下 - cd : change directory
- 切换到当前盘的其他目录下，..\表示上一级目录 - cd .. \ ..  \abc2\test200
- 切换到上一级 - cd ..
- 切换到根目录 : cd \
- 查看指定目录下所有的子集目录 -  tree
- 清屏 - cls
- 退出DOS - exit
- 其他指令 ： md [创建目录], rd[删除目录] , copy[拷贝文件] , del[删除文件] , echo[输入内容到文件] , type , move[剪切]



#### 第3章 变量

##### 3.1 变量是程序的基本组成单位

变量有三个基本要素(类型+名称+值)

int a = 1 ; //定义了一个变量，类型int整型，名称a ，值1。

##### 3.2 变量的介绍

**变量相当于内存中一个数据存储空间**的表示

 变量使用 : 声明 - int a ; 赋值 : a = 60;

##### 3.3 变量快速入门 - chapter03.java

##### 3.4 变量使用注意事项

- 变量表示内存中的一个存储区域（不同变量、类型、占用空间）
- 该区域有自己的名称
- 变量必须先声明后使用
- 该区域的数据(值)可以在**同一类型**范围内不断变化
- 变量在同一个作用域内不能重名
- 变量 = 变量名 + 值 + 数据类型，变量**三要素**

##### 3.5 程序中 + 号的使用

1. 当左右利郎便都是数值，则做加法运算
2. 左右两边有一方为字符串，则做拼接运算
3. 运算顺序从左到右

##### 3.6 数据类型

每一种数据都定低了明确的数据类型，在内存中分配了不同大小的内存空间(字节)。

**基本数据类型**  * * * * *

- 数值型
  - 整数类型,存放整数(byte[1],short[2],int[4],long[8])
  - 浮点(小数)类型(float[4],double[8])
- 字符型(char[2]) , 存放单个字符 ’a‘
- 布尔型(boolean[1])，存放 true , false

引用数据类型 

- 类(class)
- 接口(interface)
- 数组([])

##### 3.7 整数类型

用于存放整数值

- byte[字节] 		
  - 1字节，-128~127
- short[短整型]
  - 2字节，-32768~32767		(即-(2^15)~(2^15-1))
- int[整型]
  - 4字节，-(2^31)~(2^31-1)
- long[长整型]
  - 8字节，-(2^63)~(2^63-1)

**使用细节**

1. Java各整数类型有固定的范围和字段长度，不受操作系统的影响，保证java程序的可移植性。
2. Java的整型常量（具体值）默认为int型，声明long型常量须加'l'或'L'
3. Java程序中变量经常声名为int型，除非不足以表示大数，才使用long
4. bit : 计算机中的最小存储单位。byte : 计算机中基本存储单元。1 byte = 8 bit



#### 3.8 浮点类型

表示一个小数

分类：

- 单精度float
  - 4字节
- 双精度double
  - 8字节

浮点数 = 符号位 + 指数位 + 尾数位

**使用细节**

- 有固定的范围和字段长度，不受具体OS影响
- Java的浮点型常量默认为double型，声明float常量须后加'f' , 'F'。
- **两种**表示形式：十进制数形式，科学计数法形式
- 通常情况下，应该使用double型，因为它比float型更精确。
- 浮点数使用陷阱：2.7 和 8.1 / 3
  - 当我们对运算结果是小数的进行相等判断时，要小心
  - 应该是以两个数的差值的绝对值，在某个精度范围内判断

##### 3.9 Java API 文档

API 是 Java 提供的基本编程接口

中文在线文档：https://www.matools.com

Java类的组织形式 JDK 8,11

- 包1
  - 接口
  - 类(...)
    - 字段...
    - 构造器(构造方法)
    - 成员方法(方法)
  - 异常
- 包2
- 包...

如何使用ArrayList类有哪些方法：

- 包->类->方法
- 直接索引。Math

##### 3.10 字符类型（char）

可以表示单个字符，char是两个字节（可以存放汉字）

**使用细节：**

- 字符常量使用单引号( '' )括起来的单个字符。
  - 例如：char c = 'a'；
- Java中还允许使用转义字符' \ '来将其后的字符换变为特殊字符常量
  - 例如：char c = ' \n ' ;//'\n'表示换行符
- 在java中，char的本质是一个整数，输出时是unicode码对应的字符
- 可以直接给char赋一个整数，然后输出时会按照对应的unicode字符输出[97-》a]
- char类型是可以进行运算的，相当于一个整数，因为它都对应有Unicode码。



字符型存储到计算机中，需要将字符对应的码值（整数）找出来。例：

​	存储 : 'a' ==> 码值97 ==> 二进制(1100001) ==> 存储

​	读取 : 二进制(1100001) ==> 97 ===> 'a' =>显示

字符和码值的对应关系是通过字符编码表决定的（是规定好的）

字符编码表

​	ASCII（一个字节表示，一个128个字符，实际上一个字节可以表示256 个字符，只使用128个）

​	Unicode（固定大小的编码表，字母和汉字都使用两个字节来表示）

​	utf-8（编码表，大小可变的编码，字母1字节，汉字3字节）

​	gbk（可以表示汉字，而且范围广，字母1个字节，汉字2个字节）

​	gb2312（可以表示汉字，gb2312 < gbk）

​	big5（繁体中文，香港，台湾）

##### 3.11 ASCII码

##### 3.12 Unicode编码

##### 3.13 UTF-8编码

##### 3.14 布尔类型：boolean

- 布尔类型，也叫boolean类型，只允许取值true和false，无null
- 占1个字节
- 适用于逻辑运算，一般用于流程控制
  - if条件
  - while循环
  - do-while循环
  - for循环



##### 3.15 基本数据类型转换

**自动类型转换**:当java程序在进行赋值或者运算时，精度小的类型自动转换为精度大的数据类型

数据类型按精度（容量）大小排序为：（背，规则）

char-int-long-float-double

byte-short-int-long-float-double

**自动类型转换注意和细节**

1. 多种类型混合运算，首先将所有数据转换成容量最大的那种数据类型再计算
2. 把精度（容量）大的数据型赋值给精度（容量）小的数据类型时，会报错
3. （byte，short）和 char之间不会相互自动转换
4. byte，short，char三者可以计算，首先转换为int类型
5. boolean不参与转换
6. 自动提升原则：表达式结果的类型自动提升为操作数中最大的类型

**强制类型转换**

**将容量大的数据类型转换为容量小的数据类型**，使用时要加上强制转换符（），但可能造成**精度降低或溢出**

**强制类型转换细节说明：**

数据大小从大--->小

强转符号只针对于最近的操作数游侠，往往会使用小括号提升优先级

char类型keyi保存int的常量值，但不能保存int的变量值，需要强转

byte和short，char类型在进行运算时，当作int类型处理

##### 3.17 基本数据类型和String类型的转换

在程序开发中，我们经常需要将基本数据类型转成String类型（语法：将基本类型的值+""即可）

或者将String类型转成基本数据类型（语法：通过基本类型的包装类调用parseXX方法）

**注意事项：**

- 在将 String 类型转成基本数据类型时，**要确保String类型能够转成有效的数据** 。比如我们可以把 "123" , 转成一个整数，但是不能把 "hello"转成一个整数
- 如果合适不正确，就会**抛出异常，程序就会终止**

#### 第4章

##### 4.1 运算符

运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等。 

1. 算术运算符 
2. 赋值运算符
3. 关系运算符 [比较运算符] 
4. 逻辑运算符 
5. 位运算符 [需要二进制基础] 
6. 三元运算符 

##### 4.2 算数运算符

| 运算符       | 运算                                       | 例子               | 结果             |
| ------------ | ------------------------------------------ | ------------------ | ---------------- |
| +            | 正好                                       | +7                 | 7                |
| -            | 负号                                       | b=11；-b           | -11              |
| +            | 加                                         | 9+9                | 18               |
| -            | 减                                         | 10-8               | 2                |
| *            | 乘                                         | 7+8                | 56               |
| /            | 除                                         | 9/9                | 1                |
| %            | 取模（取余）                               | 11%9               | 2                |
| ++（前、后） | 自增（前：先运算后取值；后：先取值后运算） | a=2;b=++a;(b=a++;) | a=3;b=3;(b=2;)   |
| --（前、后） | 自减（前：先运算后取值；后：先取值后运算） | a=2;b=--a;(b=a--;) | a=1;b=1；（b=2） |
| +            | 字符串相加                                 | "cyq"+"nb"         | "cyq nb"         |

##### 4.3 关系运算符

==, ！=, <, >, <=, >=, instanceof(检查是否是类的对象)

**细节：**

1）结果都是boolean型，要么是true要么是false

2）关系运算符组成的表达式，为关系表达式：a>b

3）比较运算符"=="不能误写成"="



##### 4.4 逻辑运算符

&，&&，|，||，!a，a^b

&&和&的区别：

1. &&短路与：第一个条件为false，则第二个条件不会判断，效率高
2. &逻辑与：不管第一个条件是什么，第二个条件都要判断，效率低
3. 开发中，我们使用的基本都是短路与&&，效率高

##### 4.5 赋值运算符

=，+=，-+，*=，/=，%=

1. 运算顺序从右往左。 
2. 赋值运算符的左边只能是变量,右边可以是变量、表达式、常量值。
3. 复合赋值运算符会进行类型转换 。

##### 4.6 三元运算符

基本语法：

​	条件表达式？表达式1：表达式2

运算规则：

​	如果条件表达式为true，运算后的结果是表达式1；

​	如果条件表达式为false，运算后的结果是表达式2；

细节：

1. ​	 表达式1和表达式2要为可以赋给接受变量的类型（或可以自动转换）
2. ​	三元运算符可以转成if--else语句

​			int res = a > b ? a+ + : --b;

##### 4.7  运算符优先级

![运算符优先级](C:\Users\cccccyq\Desktop\GitHub\learn\Java\javatests\pics\运算符优先级.png)

1. (),{}等
2. 单目运行 ++，--
3. 算术运算符
4. 位移运算符
5. 比较运算符
6. 逻辑运算符
7. 三元运算符
8. 赋值运算符

##### 4.8 标识符的命名规则与规范

标识符的概念：Java对各种变量、方法和类等命名时使用的字符序列成为标识符

命名规则（必须遵守）：

1. 有26个英文字母大小写、0-9、_或$组成
2. 数字不可以开头
3. 不可以使用关键字和保留字，但能包含关键字和保留字
4. Java中严格区分大小写，长度无限制
5. 标识符不能包含空格

命名规范（更加专业）：

1. 包名：多单词组成时所有字母都小写：aaa.bbb.ccc 。
2. 类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz [大驼峰] 。 
3. 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz [小驼峰， 简称 驼峰法]  
4. 常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ 。
5. 后面我们学习到 类，包，接口，等时，命名规范要这样遵守，更加详细的看文档。

##### 4.9&4.10 关键字&保留字

**关键字：**

![关键字](C:\Users\cccccyq\Desktop\GitHub\learn\Java\javatests\pics\关键字.png)

![关键字2](C:\Users\cccccyq\Desktop\GitHub\learn\Java\javatests\pics\关键字2.png)

**保留字：**现有 Java 版本尚未使用，但以后版本可能会作为关键字使用，要避免使用：byValue、cast、future、 generic、 inner、 operator、 outer、 rest、 var 、 goto 、const

##### 4.11 键盘输入语句

在编程中，需要接收用户输入的数据，就可以使用键盘输入语句来获取。Input.java , 需要一个扫描器(对象), 就是Scanner

步骤：

1. 导入该类的所在包, java.util.*
2. 创建该类对象（声明变量）
3. 调用里面的功能

##### 4.12&4.13 进制&图示

对于整数，有四种表示方式： 

二进制：0,1 ，满 2 进 1.以 0b 或 0B 开头。

十进制：0-9 ，满 10 进 1。

八进制：0-7 ，满 8 进 1. 以数字 0 开头表示。 

十六进制：0-9 及 A(10)-F(15)，满 16 进 1. 以 0x 或 0X开头表示，此处的A-F不分大小写

##### 4.14 进制转换（略）

##### 4.27 原码、反码、补码

1. 二进制的最高位是符号位: 0表示正数,1表示负数
2. 正数的原码，反码，补码都一样(三码合一)
3. 负数的反码=它的原码符号位不变，其它位取反(0->1,1->0)
4. 负数的补码=它的反码+1，负数的反码 =负数的补码 - 1
5. 0的反码，补码都是0
6. java没有无符号数，换言之，java中的数都是有符号的
7. 在计算机运算的时候，都是以**补码的方式来运算**的.
8. 当我们看运算结果的时候，要看他的**原码(**重点)

##### 4.28 位运算符

&、|、^、~、>>、<<、>>>

按位与&	   ：	两位全为1，结果为1，否则为0

按位或|		：	两位有一个为1，结果为1，否则为0

按位异或^	：	两位一个为0,一个为1，结果为1，否则为0

按位取反~	：	0->1,1->0

算术右移 >>：低位溢出,符号位不变,并用符号位补溢出的高位

算术左移 <<：符号位不变,低位补 0

逻辑右移>>>：也叫无符号右移,运算规则是: 低位溢出，高位补 0



特别说明：没有 <<< 符号



#### 第5章 程序控制结构

##### 5.1 介绍

在程序中，程序运行的流程控制决定程序是如何执行的，是我们必须掌握的，主要有三大流程控制语句：顺序、循环、分支

##### 5.2 顺序控制

程序从上到下逐行执行

##### 5.3 分支控制if-else

单分支 if

双分支 if-else

多分支if-else if -...-else

##### 5.5 嵌套分支

**在一个分支结构中又完整的嵌套了另一个完整的分支结构**，里面的分支的结构称为内层分支外面的分支结构称为外 层分支。建议:不超过3层，可读性不好。

##### 5.6 switch分支结构

```java
switch(表达式){
    case 常量1:
    语句块1;
    break;
    case 常量2; 
    语句块2;
    break;
    ...
    case 常量n;
    语句块1;
    break;
    default:
    default语句块;
    break;
}
```

1. switch 关键字，表示swtich分支
2. 表达式对应一个值
3. case 常量1:当表达式的值等于常量1，就执行 语句块1
4. break : 表示退出swtich
5. 如果和 case 常量1 匹配，就执行语句块1，如果没有匹就继续匹配 case 常量2
6. 如果一个都没有匹配上，执行default



###### switch和if比较：

1. 如果判断的具体数值不多，而且符合 byte、short、int、char,enum[枚举], String 这 6 种类型。虽然两个语句都可以使用，建议使用 swtich 语句。
2. 其他情况：对区间判断，对结果为 boolean 类型判断，使用 if，if 的使用范围更广。

##### 5.7 循环控制

```java
for(循环变量初始化；循环条件；循环变量迭代){
    循环操作(可以多条语句)；
}
```

1. for 关键字，表示循环控制 
2. for 有四要素: (1)循环变量初始化(2)循环条件(3)循环操作(4)循环变量迭代 
3. 循环操作 , 这里可以有多条语句，也就是我们要循环执行的代码 
4. 如果 循环操作(语句) 只有一条语句，可以省略 {}, 建议不要省略

**注意事项和细节说明**

1. 循环条件是返回一个布尔值的表达式 
2. for(;循环判断条件;) 中的初始化和变量迭代可以写到其它地方，但是两边的分号不能省略。 
3. 循环初始值可以有多条初始化语句，但要求类型一样，并且中间用逗号隔开，循环变量迭代也可以有多条变量迭代 语句，中间用逗号隔开。

##### 5.8 while循环控制

```java
循环变量初始化;
while(循环条件){
    循环体(语句);
    循环变量迭代;
}
```

注意：

1. 循环条件是返回一个布尔值的表达式 
2. while 循环是先判断再执行语句



##### 5.9 do..while循环控制

```java
循环变量初始化;
do{
    循环体(语句); 
    循环变量迭代;
}while(循环条件);
```

注意：

1. 循环条件是返回一个布尔值的表达式 
2. do..while 循环是先执行，再判断， 因此它至少执行一次



##### 5.10 多重循环控制

1. 将一个循环放在另一个循环体内，就形成了嵌套循环。其中，for ,while ,do…while 均可以作为外层循环和内层循环。一般不超过三层否则代码可读性很差。
2. 实质上，嵌套循环就是把内层循环当成外层循环的循环体。当只有内层循环的循环条件为 false 时，才会完全跳出内 层循环，才可结束外层的当次循环，开始下一次的循环。
3. 设外层循环次数为 m 次，内层为 n 次，则内层循环体实际上需要执行 m*n 次。



##### 5.11 跳转控制语句-break

**break 语句用于终止某个语句块的执行**，一般使用在 switch 或者循环[for , while , do-while]中.

##### 5.12 跳转控制语句-continue

介绍

1. continue 语句用于结束本次循环，继续执行下一次循环。
2. continue 语句出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环 , 这个和前面的标签的 使用的规则一样

##### 5.13 跳转控制语句-return

return 使用在方法，表示跳出所在的方法.



#### 第6章 数组、排序和查找

##### 6.1 数组

数组可以存放多个同一类型的数据。数组也是一种数据类型，是引用类型。

##### 6.2 使用

1）动态初始化

定义、引用

```java
//定义：方法一：
数据类型 数组名[] = new 数据类型[大小]
int a[] = new int[5];
//方法二：先声明数组，再new分配空间
int a[];int[]a;//这俩都可，声明数组，此时a是null
a = new int[5];//分配内存空间，可以存放数据
//创建了一个数组，名字a，存放5个int
//引用：
数组名[下表/索引/index]
    a[3]
```

2）静态初始化

```java
数据类习惯 数组名[] = {元素值,元素值,元素值...}
int a[] = {2,5,6,7,8,89,34,23,12};
```

##### 6.3 注意事项和细节

1. 数组是多个相同类型数据的组合，实现对这些数据的统一管理
2. 数组中的元素可以是任何数据类型，包括基本类型和引用类型，但是不能混用。
3. 数组创建后，如果没有赋值，有默认值：int 0，short 0，byte 0，long 0，float 0.0，double 0.0，char \u0000，boolean false，String null。
4. 使用数组的步骤：1. 声明数组并开辟空间 2 给数组各个元素赋值 3 使用数组 
5. 数组的**下标是从 0 开始的**。
6. 数组下标必须在指定范围内使用，否则报：下标越界异常，比如int [] arr=new int[5]; 则有效下标为 0-4 
7. 数组属引用类型，数组型数据是对象(object)

##### 6.4 数组应用案例

##### 6.5 数组赋值机制

1. 基本数据类型赋值，这个值就是具体的数据，而且相互不影响。 int n1 = 2; int n2 = n1; 
2. 数组在默认情况下是引用传递，赋的值是地址。 
   看一个案例，并分析数组赋值的内存图(重点, 难点. )。
   int[] arr1 = {1,2,3}; 
   int[] arr2 = arr1;

##### 6.6-6.7 数组拷贝、反转

##### 6.8 数组添加/扩容

##### 6.9 排序

排序是将多个数据，依指定的顺序进行排列的过程。

内部排序：指将需要处理的所有数据都加载到内部存储器中进行排序。包括(交换式排序法、选择 式排序法和插入式排序法。

外部排序：数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。包括(合并排序法和直接合并排序法）。

##### 6.10-6.11 冒泡排序法

冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从后向前（从下标较大的元素开始），依次比较相邻元素 的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。

##### 6.12 查找

在 java 中，我们常用的查找有两种:

1. 顺序查找
2. 二分查找



#####  6.13-6.14 多维数组-二维数组&使用

使用：

```java
//动态初始化，方法1
	类型[][] 数组名 = new 类型[大小][大小]
	//例如：
	int a[][] = new int [2][3]
//动态初始化，方法2
	先声明：类型 数组名[][];
	再定义(开辟空间):数组名 = new 类型[大小][大小]
	赋值(有默认值，比如int类型的就是0)
//动态初始化，当列数不确定
	int[][] arr = new int[3][]; 
	//再通过循环等其他方式对每一个一维数组开数据空间
//静态初始化
	定义 类型 数组名[][] = {{值1,值2,...},{值1,值2,...},{值1,值2,...}};
	//举例：
	 int[][]arr = {{1,1,1},{8,8,9},{100}};

```

##### 6.15 二维数组应用案例（略）

##### 6.16 二维数组使用细节和注意事项：

一维数组的声明方式：

```java
int[]x;
int x[];
```

二维数组的声明方式：

```java
int [][] y;
int[]y[];
int y[][]
```

二维数组实际上是由多个一维数组组成的，它的各个一维数组的长度可以相同，也可以不相同。
比如：

```java
//map[][] 是 一个二维数组
int map[][] = {{1,2},{3,4,5}};
//由 map[0] 是一个含有两个元素的一维数组 ，map[1] 是一个含有三个元素的一维数组构成，我们也称为列数不等的二维数组

```



#### 第7章 面向对象编程(基础部分)

##### 7.1 类和对象

使用单独的变量解决、使用数组解决=>不利于数据的管理、效率低，因此引入类与对象(OOP)

```java
//定义一个猫类Cat -> 自定义数据类型
class Cat {
    //属性
    String name;
    int age;
    String color;
}
public class md{
	public static void main(String[] args){
        Cat cat1 = new Cat();
        //创建一只猫，并赋给cat1
        cat1.name = "丁真"；
        cat1.age = 3;
        cat1.color = "白色"；
        cat2.name = "我测";
        cat2.age = 100;
        cat2.color = "黄色"；
            
        //访问对象属性：
        System.out.println("name="+cat1.name+"age="+cat1.age+"color"+cat1.color);
}
```

1. 类是抽象的，概念的，代表一类事物,比如人类,猫类.., 即它是数据类型。
2. 对象是具体的，实际的，代表一个具体事物, 即 是实例。
3. 类是对象的模板，对象是类的一个个体，对应一个实例。

**属性、成员变量、字段：**

1. 从概念或叫法上看： 成员变量 = 属性 = field(字段) （即成员变量是用来表示属性的）
2. 属性是类的一个组成部分，一般是基本数据类型,也可是引用类型(对象，数组)。比如我们前面定义猫类 的 int age 就 是属性

**注意事项和细节说明**

1. 属性的定义语法同变量，示例：访问修饰符 属性类型 属性名; 
   访问修饰符： 控制属性的访问范围 
   有四种访问修饰符 public, proctected, 默认, private 
2. 属性的定义类型可以为任意类型，包含基本类型或引用类型
3. 属性如果不赋值，有默认值，规则和数组一致。
   具体说: int 0，short 0, byte 0, long 0, float 0.0,double 0.0，char \u0000， boolean false，String null

**类和对象的内存分配机制**

Java 内存的结构分析 

1. 栈： 一般存放基本数据类型(局部变量) 
2. 堆： 存放对象(Cat cat , 数组等) 
3. 方法区：常量池(常量，比如字符串)， 类加载信息 
4. 示意图 [Cat (name, age,price)]

Java 创建对象的流程简单分析

1. 先加载 Person 类信息(属性和方法信息, 只会加载一次)
2. 在堆中分配空间, 进行默认初始化(看规则)
3. 把地址赋给 p , p 就指向对象
4. 进行指定初始化， 比如 p.name =”jack” p.age = 10



##### 7.2 成员方法

在某些情况下，我们要需要定义成员方法(简称方法)。比如人类:除了有一些属性外( 年龄，姓名..),我们人类还有一 些行为比如:可以说话、跑步..,通过学习，还可以做算术题。这时就要用**成员方法**才能完成。现在要求对 Person 类完善。

```java
public class Method01 { 
	//编写一个main方法
	public static void main(String[] args) {
		//方法使用
		//1. 方法写好后，如果不去调用(使用)，不会输出
		//2. 先创建对象 ,然后调用方法即可
		Person p1 = new Person();
		p1.speak(); //调用方法
		p1.cal01(); //调用cal01方法
		p1.cal02(5); //调用cal02方法，同时给n = 5
		p1.cal02(10); //调用cal02方法，同时给n = 10
		
		//调用getSum方法，同时num1=10, num2=20
		//把 方法 getSum 返回的值，赋给 变量 returnRes
		int returnRes = p1.getSum(10, 20); 
		System.out.println("getSum方法返回的值=" + returnRes);
	}
}

class Person {
	
	String name;
	int age;
	//方法(成员方法)
	//添加speak 成员方法,输出 “我是一个好人”	
	public void speak() {
		System.out.println("我是一个好人");
	}
	//1. public 表示方法是公开
	//2. void ： 表示方法没有返回值
	//3. speak() : speak是方法名， () 形参列表
	//4. {} 方法体，可以写我们要执行的代码
	//5. System.out.println("我是一个好人"); 表示我们的方法就是输出一句话
    
	//添加cal01 成员方法,可以计算从 1+..+1000的结果
	public void cal01() {
		//循环完成
		int res = 0;
		for(int i = 1; i <= 1000; i++) {
			res += i;
		}
		System.out.println("cal01方法 计算结果=" + res);
	}
	//添加cal02 成员方法,该方法可以接收一个数n，计算从 1+..+n 的结果
	
	//1. (int n) 形参列表， 表示当前有一个形参 n, 可以接收用户输入
	public void cal02(int n) {
		//循环完成
		int res = 0;
		for(int i = 1; i <= n; i++) {
			res += i;
		}
		System.out.println("cal02方法 计算结果=" + res);
	}

	//添加getSum成员方法,可以计算两个数的和
	public int getSum(int num1, int num2) {
		int res = num1 + num2;
		return res;
	}
}
//1. public 表示方法是公开的
	//2. int :表示方法执行后，返回一个 int 值
	//3. getSum 方法名
	//4. (int num1, int num2) 形参列表，2个形参，可以接收用户传入的两个数
	//5. return res; 表示把 res 的值， 返回
```

###### **方法的调用机制**

![方法](C:\Users\cccccyq\Desktop\GitHub\learn\Java\javatests\pics\方法.png)

###### **成员方法的好处、必要性**

1. 提高代码的复用性 
2. 可以将实现的细节封装起来，然后供其他用户来调用即可

###### **成员方法的定义**

```java
访问修饰符 返回数据类型 方法名（形参列表..） {//方法体
	语句；
	return 返回值;
}
```

1. 形参列表：表示成员方法输入 cal(int n) ， getSum(int num1, int num2)
2. 返回数据类型：表示成员方法输出, void 表示没有返回值 
3. 方法主体：表示为了实现某一功能代码块 
4. return 语句不是必须的

###### **访问修饰符** 

(作用是控制 方法使用的范围) 

如果不写默认访问，[有四种: public, protected, 默认, private],

###### **返回数据类型**

一个方法最多有一个返回值 [思考，如何返回多个结果 返回数组 ] 

返回类型可以为任意类型，包含基本类型或引用类型(数组，对象) 

如果方法要求有返回数据类型，则方法体中最后的执行语句必须为 return 值; 而且要求返回值类型必须和 return 的 值类型一致或兼容 

如果方法是 void，则方法体中可以没有 return 语句，或者只写 return;

###### **方法名**

遵循驼峰命名法，最好见名知义，表达出该功能的意思即可, 比如 得到两个数的和 getSum, 开发中按照规范

###### **形参列表**

1. 一个方法可以有0个参数，也可以有多个参数，中间用逗号隔开,比如 getSum(int n1，int n2)
2. 参数类型可以为任意类型，包含基本类型或引用类型，比如 printArr(int[] [] map)
3. 调用带参数的方法时，一定对应着参数列表传入相同类型或兼容类型 的参数![getSum]
4. 方法定义时的参数称为形式参数，简称形参;方法调用时的传入参数称为实际参数，简称实参实参和形参的类型要一致或兼容、个数、顺序必须一致!

###### **方法体**

里面写完成功能的具体的语句，可以为输入。输出、变量、运算、分支、循环、方法调用，但里面不能再定义方法!即: 方法不能嵌套定义。

###### **方法调节细节说明**

1. 同一个类中的方法调用: 直接调用即可。比如 print(参数);
   案例演示: A类 sayok 调用 print0
2. 跨类中的方法A类调用B类方法: 需要通过对象名调用。比如 对象名方法名(参数);
   案例演示: B类 sayHello 调用 print()
3. 特别说明:跨类的方法调用和方法的访问修饰符相关，访问修饰符细说。



**类定义的完善**

略：）

##### 7.3 成员方法传参机制！

基本数据类型，传递的是值 (值拷贝)，形参的任何改变不影响实参

引用类型传递的是地址（传递也是值，但是值是地址），可以通过形参影响实参！



##### 7.4 方法递归调用

简单的说: **递归就是方法自己调用自己**,每次调用时传入不同的变量.递归有助于编程者解决复杂问题,同时可以让代码变 得简洁

**递归重要规则**

1. 执行一个方法时，就创建一个新的受保护的独立空间(栈空间)
2. 方法的局部变量是独立的，不会相互影响,比如n变量
3. 如果方法中使用的是引用类型变量(比如数组，对象)，就会共享该引用类型的数据
4. 递归必须向退出递归的条件逼近，否则就是无限递归,出现StackOverflowError，死龟了:)
5. 当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕

方法递归举例题目

```java
//p220-p227
//递归斐波那契数列
//老鼠出迷宫
//汉诺塔
//八皇后
```



##### 7.5 方法重载

java 中允许同一个类中，多个同名方法的存在，但要求 形参列表不一致

好处在于：

1. 减轻了起名的麻烦 
2. 减轻了记名的麻烦

**注意事项和使用细节**

1. 方法名：必须相同
2. 形参列表：必须不同（形参类型或个数顺序，至少有一样不同，参数名无要求）
3. 返回类型：无要求





##### 7.6 可变参数

java 允许将同一个类中**多个同名同功能**但**参数个数不同**的方法，封装成一个方法。 就可以通过可变参数实现

基本语法：

```java
/*
访问修饰符 返回类型 方法名(数据类型... 形参名){
}
*/
public int sum(int... nums){
    int res = 0;
    for(int i = 0; i<nums; i++){
        res += nums[i];
    }
    return res;
}

```

注意事项和使用细节

1. 可变参数的实参可以为0个或任意多个
2. 可变参数的实参可以为数组。
3. 可变参数的本质就是数组
4. 可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后
5. 一个形参列表中只能出现一个可变参数





##### 7.7 作用域

1. 在java编程中，主要的变量就是属性(成员变量)和局部变量。
2. 我们说的局部变量一般是指在成员方法中定义的变量。
   [举例 Cat类: cry]
3. java中作用域的分类：
   全局变量: 也就是属性，作用域为整个类体 Cat类: cry eat 等方法使用属性[举例]
   局部变量:也就是除了属性之外的其他变量，作用域为定义它的代码块中!
4. 全局变量(属性)可以不赋值，直接使用，因为有默认值，局部变量必须赋值后才能使用，因为没有默认值。



注意事项和使用细节

1. 属性和局部变量可以重名，访问时遵循就近原则。
2. 在同一个作用域中，比如在同一个成员方法中，两个局部变量，不能重名。
3. **属性生命周期较长**伴随着对象的创建而创建，伴随着对象的销毁而销毁。局部变量，**生命周期较短**，伴随着它的代码块的执行而创建，伴随着代码块的结束而销毁.即在一次方法调用过程中。
4. 作用域范围不同：
   全局变量/属性:可以被本类使用，或其他类使用(通过对象调用)
   局部变量:只能在本类中对应的方法中使用
5. 修饰符不同：
   全局变量/属性可以加修饰符
   局部变量不可以加修饰符



##### 7.8 构造方法/构造器

构造方法又叫构造器(constructor)，是类的一种特殊的方法，它的主要作用是完成对新对象的初始化。

特点：

1. 方法名和类名相同
2. 没有返回值
3. 在创建对象时，系统会自动的调用该类的构造器完成对象的初始化。

基本语法:

```java
[修饰符] 方法名(形参列表){
    方法体;
}
/*
1)构造器的修饰符可以默认，也可以是 public protected private
2)构造器没有返回值
3)方法名和类名字必须一样
4)参数列表和成员方法一样的规则
5)构造器的调用，由系统完成
*/
```

注意事项和使用细节

1. 一个类可以定义多个不同的构造器，即构造器重载
   比如: 我们可以再给Person类定义一个构造器,用来创建对象的时候,只指定人名不需要指定年龄
2. 构造器名和类名要相同
3. 构造器没有返回值
4. 构造器是完成对象的初始化，并不是创建对象
5. 在创建对象时,系统自动的调用该类的构造方法
6. 如果程序员没有定义构造器，系统会自动给类生成一个默认无参构造器(也叫默认构造器)，比如 Dog(){},使用 **javap指令** 反编译看看
7. 一旦定义了自己的构造器+,默认的构造器就覆盖了，就不能再使用默认的无参构造器，除非显式的定义一下,即: (){} 写(**这点很重要**)



##### 7.9 对象创建的流程

加载Person类信息(Person.class)，只会加载一次

再堆中分配空间(地址)

**完成对象初始化**[默认初始化--显式初始化--构造器初始化]

把对象在堆中的地址返回给对象名（也可以理解成是对象的引用）

##### 7.10 this关键字

java虚拟机会给每个对象分配this，代表当前对象，即哪个对象调用，this就代表哪个对象。

**this注意事项和使用细节**

1. this 关键字可以用来访问本类的属性、方法、构造器
2. this 用于区分当前类的属性和局部变量
3. 访问成员方法的语法: this.方法名(参数列表)；
4. 访问构造器语法: this(参数列表)
   注意**只能在构造器中使用(即只能在构造器中访问另外一个构造器。必须放在第一条语句)**
5. this 不能在类定义的外部使用，只能在类定义的方法中使用。



#### 第8章 面向对象编程（中级部分）

##### 8.1 IDEA

##### 8.2 Eclipse

##### 8.3 IDEA使用

快捷键(自用)

Ctrl+D		 复制当前行

Alt +D		  删除当前行

Alt + / 		 补全代码

Ctrl + / 	    添加/取消注释

Alt + Enter  		导入改行需要的类

Ctrl + Alt + L 	   快速格式化代码(调整用)

Alt+R//Shift+F10 	快速运行程序

Alt+insert		生成构造器等

Ctrl+H			查看一个类的层级关系

Ctri+B			定位到方法

.var				自动的分配变量名

##### 8.4 包

**作用**

1. 区分相同名字的类
2. 当类很多时,可以很好的管理类 [看Java API 文档]
3. 控制访问范围

**基本语法**

```java
package com.cccccyq;
//1 package 关键字，表示打包
//2 com.cccccyq：表示包名
```

**包的本质实际上就是创建不同的个文件夹/目录来保存类文件**

命名规则：只能包含数字、字母、下划线、小圆点，但是不能用数字开头，不能是关键字或保留字

命名规范：一般是小写字母+小圆点，一般是com.公司名.项目名.业务模块名

例如：com.sina.crm.order / com.sina.crm.user

###### **常用的包**

```java
java.lang.*
//是基本包，默认引入，不需要再引入
java.util.*
//util包，系统提供的工具包，工具类，使用Scanner
java.net.*
//网络包，网络开发
java.awt.*
//是做java的界面开发，GUI
```

引入包：

```java
com.cccccyq.pkg:import1.java
   
//package 的作用是声明当前类所在的包，需要放在类的最上面，一个类中最多只有一句package
package com.cccccyq.pkg
//import指令 位置放在package的下面，在类定义前面,可以有多句且没有顺序要求
import java.util.Scanner;
public class test001{
    public static void main(String[] args){
        ...
    }
}
```



##### 8.5 访问修饰符

java 提供四种访问控制修饰符号，用于控制方法和属性(成员变量)的访问权限（范围）:

1. 公开级别:用 public 修饰,对外公开
2. 受保护级别:用 protected 修饰,对子类和同一个包中的类公开
3. 默认级别:没有修饰符号,向同一个包的类公开
4. 私有级别:用 private 修饰,只有类本身可以访问,不对外公开

###### **访问范围**

| 访问级别 | 访问控制修饰符 | 同类 | 同包 | 子类 | 不同包 |
| -------- | -------------- | ---- | ---- | ---- | ------ |
| 公开     | public         | √    | √    | √    | √      |
| 受保护   | protected      | √    | √    | √    | X      |
| 默认     | 没有修饰符     | √    | √    | X    | X      |
| 私有     | private        | √    | X    | X    | X      |

注意事项

1. 修饰符可以用来修饰类中的属性，成员方法以及类
2. 只有默认的和public才能修饰类!，并且遵循上述访问权限的特点
3. 因为没有学习继承，因此关于在子类中的访问权限
4. 成员方法的访问规则和属性完全一样。



##### 8.6 面向对象编程三大特征

封装、继承和多态

##### 8.7**封装**

封装(encapsulation)就是把抽象出的数据[**属性**]和对数据的操作[**方法**]封装在一起，数据被保护在内部,程序的其它部分只有通过被授权的操作作[**方法**],才能对数据进行操作。

好处：

1. 隐藏实现细节 : 方法(连接数据库)<--调用(传入参数..)
2. 可以对数据进行验证，保证安全合理

实现步骤：

将属性进行私有化private[不能直接修改属性]

1. 提供一个公共的(public)set方法，用于对属性判断并赋值
   public void setXxx(类型 参数名){//Xxx 表示某个属性
   	//加入数据验证的业务逻辑
   	属性 = 参数名;
   }
2. 提供一个公共的(public)get方法，用于获取属性的值
   public 数据类型 getXxx()[ //权限判断,Xxx 某个属性
   	return xx;
3. }

##### 8.8**继承**

继承可以解决代码复用,让我们的编程更加靠近人类思维.当多个类存在相同的属性(变量)和方法时,可以从这些类中 抽象出父类,在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过 extends 来 声明继承父类即可。

基本语法：

```java
class子类 extends 父类{
}
```

1. 子类就会自动拥有父类定义的属性和方法
2. 父类又叫 超类，基类
3. 子类又叫派生类

继承的好处：

1. 代码的复用性提高了
2. 代码的扩展性和维护性提高了

细节：

1. 子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问，但是私有属性和方法不能在子类直接访问，要通过父类提供公共的方法去访问。
2. 子类必须调用父类的构造器，完成父类的初始化
3. 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用 super 去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过。
4. 如果希望指定去调用父类的某个构造器，则显式的调用一下 : super(参数列表)
5. super 在使用时，必须放在构造器第一行(super 只能在构造器中使用)
6. super() 和 this() 都只能放在构造器第一行，因此这两个方法不能共存在一个构造器
7. java 所有类都是 Object 类的子类,Object 是所有类的基类
8. 父类构造器的调用不限于直接父类!将一直往上追溯直到 Obiect 类(顶级父类)
9. 子类最多只能继承一个父类(指直接继承)，即 java 中是单继承机制.
   思考: 如何让 A 类继承 B 类和 C类? [A 继承 B，B 继承 C]
10. 不能滥用继承，子类和父类之间必须满足 is-a 的逻辑关系

继承的**本质**&&内存布局  

```java
package com.hspedu.extend_;

/**
 * 讲解继承的本质
 */
public class ExtendsTheory {
    public static void main(String[] args) {
        Son son = new Son();//内存的布局
        //?-> 这时注意，要按照查找关系来返回信息
        //(1) 首先看子类是否有该属性
        //(2) 如果子类有这个属性，并且可以访问，则返回信息
        //(3) 如果子类没有这个属性，就看父类有没有这个属性(如果父类有该属性，并且可以访问，就返回信息..)
        //(4) 如果父类没有就按照(3)的规则，继续找上级父类，直到Object...
        System.out.println(son.name);//返回就是大头儿子
        //System.out.println(son.age);//返回的就是39
        //System.out.println(son.getAge());//返回的就是39
        System.out.println(son.hobby);//返回的就是旅游
    }
}

class GrandPa { //爷类
    String name = "大头爷爷";
    String hobby = "旅游";
}

class Father extends GrandPa {//父类
    String name = "大头爸爸";
    private int age = 39;

    public int getAge() {
        return age;
    }
}

class Son extends Father { //子类
    String name = "大头儿子";
}


```

​                                                   

##### 8.9 super关键字

super 代表父类的引用，用于**访问父类的属性、方法、构造器**

基本语法：

1. 访问父类的属性，但不能访问父类的private属性
   super.属性名;
2. 访问父类的方法，不能访问父类的private方法
   super.方法名(参数列表);
3. 访问父类的构造器:
   super(参数列表);	//只能放在构造器的第一句，只能出现一句!

好处：

1. 调用父类的构造器的好处 (分工明确,父类属性由父类初始化，子类的属性由子类始化)
2. 当子类中有和父类中的成员(属性和方法)重名时，为了访问父类的成员，必须通过super。如果没有重名使用super、this、直接访问是一样的效果!
3. super的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员;如果多个基类(上级类)中都有同名的成员，，使用super访问遵循就近原则。A->B->C，当然也需要遵守访问权限的相关规则



super和this比较：

| No.  | 区别点     | this                                                 | super                              |
| ---- | ---------- | ---------------------------------------------------- | ---------------------------------- |
| 1    | 访问属性   | 访问本类中的属性，如果本来没有此属性则从父类继续查找 | 从父类开始查找属性                 |
| 2    | 调用方法   | 访问本类中的方法，如果本来没有此方法则从父类继续查找 | 从符类开始查找方法                 |
| 3    | 调用构造器 | 本类构造器，必须放在构造器的首行                     | 符类构造器，必须放在子类构造器首行 |
| 4    | 特殊       | 表示当前对象                                         | 子类中访问父类对象                 |



##### 8.10 方法重写/覆盖(override)

方法覆盖(重写)就是子类有一个方法,和父类的某个方法的名称、返回类型、参数一样,那么我们就说子类的这个方法覆盖了父类的方法。

注意事项和使用细节：

1. 子类的方法的形参列表,方法名称,要和父类方法的形参列表,方法名称完全一样。
2. 子类方法的返回类型和父类方法返回类型一样，或者是父类返回类型的子类比如父类 返回类型是 Object,子类方法返回类型是String
3. 子类方法不能缩小父类方法的访问权限
    public > protected > 默认>private

比较：

| 名称           | 发生范围 | 方法名   | 形参列表                         | 返回参数                                                     | 修饰符                             |
| -------------- | -------- | -------- | -------------------------------- | ------------------------------------------------------------ | ---------------------------------- |
| 重载(overload) | 本类     | 必须一样 | 类型，个数或者顺序至少有一个不同 | 无要求                                                       | 无要求                             |
| 重写(override) | 父子类   | 必须一样 | 相同                             | 子类重写的方法，返回的类型和父类返回的类型一致，或者是其子类 | 子类方法不能缩小父类方法的访问范围 |

##### 8.11 多态

方法或对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承基础之上的。

多态的具体体现：

- 方法的多态-重写和重载就体现多态
- 对象的多态(多态的核心)

```java
举例说明：
1）一个对象的编译类型和运行类型可以不一致:
Animal animal = new Dog();
//animal编译类型是Animal,运行类型Dog。

2）编译类型在定义对象时，就确定了，不能改变
    
3）运行类型是可以变化的。
animal = new Cat();
//animal的运行类型变成了Cat,编译类型仍然是Animal

4）编译类型看定义时=号的左边，运行类型看=号的右边
```

**注意事项和讨论细节**：

 多态的**前提**是：两个对象(类)存在继承关系

多态的向上转型：

1. 本质:父类的引用指向了子类的对象
2. 语法:父类类型引用名 = new 子类类型();
3. 特点: 编译类型看左边，运行类型看右边
   可以调用父类中的所有成员(需遵守访问权限)，不能调用子类中特有成员;（因为在编译阶段，能调用哪些成员吗，是由编译类型来决定的）
   最终运行效果看子类的具体实现（调用方法的时候，按照子类开始查找方法，然后调用，规则和前面的方法调用规则一致）

多态向下转型：

1. 语法: 子类类型 引用名 = (子类类型)  父类引用
2. 只能强转父类的引用，不能强转父类的对象
3. 要求父类的引用必须指向的是当前目标类型的对象
4. 当向下转型后，可以调用子类类型中所有的成员



注意：

1. 属性没有重写之说，属性的值看编译类型
2. instanceOf比较操作符，用于判断对象的类型是否为XX类型或者XX类型的子类型

###### **java的动态绑定机制**：

1. 当调用对象方法的时候，**该方法会和该对象的内存地址/运行类型**绑定
2. 当调用对象属性时，**没有动态绑定机制**，哪里声明，那里使用

应用：

1. 多态数组-数组的定义类型为父类类型，里面保存的实际元素类型为子类类型

2. 多态参数-方法定义的形参类型为父类类型，实参类型允许为子类类型

   

//多态这俩运用学习得不是很理想，改日再听！！！

↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑

##### 8.12 Object类详解

###### **equals方法**

==和equals对比：

1. ==既可以判断基本类型，又可以判断引用类型
2. ==如果判断基本类型，判断的是值是否相等。
3. ==如果判断引用类型，判断的是地址是否相等，即判定是不是同一个对象
4. equals:是Object类中的方法，只能判断引用类型
5. equals默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等。比如Integer,String。

###### **hashCode方法**

public int hashCode()

返回该对象的哈希码值，支持此方法是为了提高哈希表的性能。

实际上，由Object类定义的hashCode方法确实会针对不同对象返回不同的整数(这一般是通过将该对象的内部地址转换成一个整数来实现的，但是Java编程语言不需要这种实现技巧)



1. 提高具有哈希结构的容器的效率!
2. 两个引用，如果指向的是同一个对象，则哈希值肯定是一样的!
3. 两个引用，如果指向的是不同对象，则哈希值是不一样的
4. 哈希值主要根据地址号来的!， 不能完全将哈希值等价于地址。
5. 如果需要也会重写。

###### toString方法

默认返回：全类名+@+哈希值的十六进制

1. 子类往往重写 toString 方法，用于返回对象的属性信息
2. 重写 toString 方法，打印对象或拼接对象时，都会自动调用该对象的 toString 形式.
3. 当直接输出一个对象时，toString 方法会被默认的调用, 比如 System.out.println(monster)； 就会默认调用monster.toString()

###### finalize方法

1. 当对象被回收时，系统自动调用该对象的 finalize 方法。子类可以重写该方法，做一些释放资源的操作
2. 什么时候被回收：当某个对象没有任何引用时，则 jvm 就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来 销毁该对象，在销毁该对象前，会先调用 finalize 方法。
3. 垃圾回收机制的调用，是由系统来决定(即有自己的 GC 算法), 也可以通过 System.gc() 主动触发垃圾回收机制。

实际开发中，几乎不会运用 finalize ,（所以更多就是为了应付面试)

##### 8.13 断点调试(debug)

1. 断点调试是指在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。进行分析从而找到这个Bug
2. 断点调试是程序员必须掌握的技能。
3. 断点调试也能帮助我们查看java底层源代码的执行过程，提高程序员的Java水平

快捷键：

F7 : 跳入方法内

F8 : 逐行执行代码

shift + F8 : 跳出方法

F9 : resume，执行到下一个断点（断点可以在Debug过程中动态地下断点。）



#### 第9章 项目-房屋出租系统

///

#### 第10章 面向对象编程(高级部分)

##### 10.1 类变量和类方法

类变量也叫静态变量静态属性，是该类的所有对象共享的变量,任何一个该类的对象去访问它时,取到的都是相同的值,同样任何一个该类的对象去修改它时,修改的也是同一个变量。

###### 类变量

```java
//定义类变量：
访问修饰符 static 数据类型 变量名；（这个更好）
static 访问修饰符 数据类型 变量名；
    
//访问类变量：
类名.类变量名（更推荐）
对象名.类变量名
    
//静态变量的访问修饰符的访问权限和范围和普通属性是一样的
```

###### 类变量的内存布局

- 不管静态变量是放在堆里面还是方法区的静态域里面的，这个静态变量是被对象共享的，放在哪不影响堆静态变量的使用。
- jdk8之前放在方法区，jdk8以后是放在堆里面，有一个class对象，会在类加载过后生成这个class对象，通过这个对象可以拿到很多类的信息。因此，有两个共识：
  - static变量是同一个类所有对象共享
  - static类变量，在类加载的时候就生成了

###### 类变量使用注意事项和细节讨论

1. 什么时候需要用类变量当我们需要让某个类的所有对象都共享一个变量时，就可以考虑使用类变量(静态变量): 比如:定义学生类，统计所有学生共交多少钱。Student (name, staticfee)
2. 类变量与实例变量(普通属性) 区别类变量是该类的所有对象共享的，而实例变量是每个对象独享的.
3. 加上static称为类变量或静态变量，否则称为实例变量/普通变量/非静态变量
4. 类变量可以通过 类名.类变量名 或者 对象名类变量名 来访问，但iava设计者推荐我们使用 类名.类变量名方式访问。[前提是 满足访问修饰符的访问权限和范围]
5. 实例变量不能通过 类名.类变量名 方式访问
6. 类变量是在类加载时就初始化了，也就是说，即使你没有创建对象，只要类加载了就可以使用类变量了。
7. 类变量的生命周期是随类的加载开始随着类消亡而销毁

###### 类方法

```java
//类方法也叫静态方法

//定义形式如下:
访问修饰符 static 数据返回类型 方法名(){ }  //(更推荐)
static 访问修饰符 数据返回类型 方法名(){ }

//调用形式如下:
类名.类方法名
对象名.类方法名  //（这个的前提是满足访问修饰符地访问权限）
    
//当方法中不涉及到任何和对象相关的成员，则可以将方法设计成静态方法,提高开发效率。比如: 工具类中的方法 utilsMath类、Arrays类、Collections 集合类
//在程序员实际开发，往往会将一些通用的方法，设计成静态方法，这样我们不需要创建对象就可以使用了，比如打印一维数组，冒泡排序, 完成某个计算任务 等... 
```

###### 类方法使用注意事项和细节讨论

1. 类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区
   - 类方法中无this的参数
   - 普通方法中隐含着this的参数
2. 类方法可以通过类名调用，也可以通过对象名调用。
3. 普通方法和对象有关，需要通过对象名调用，比如对象名.方法名(参数)，不能通过类名调用
4. 类方法中不允许使用和对象有关的关键字，比如this和super。普通方法(成员方法)可以
5. 类方法(静态方法)中只能访问静态变量或静态方法
6. 普通成员方法，既可以访问非静态成员，也可以访问静态成员。

小结:：静态方法，只能访问静态的成员，非静态的方法，可以访问静态成员和非静态成员（必须遵守访问权限）

##### 10.2 理解main方法语法

![main方法](C:\Users\cccccyq\Desktop\GitHub\learn\Java\javatests\pics\main方法.png)

提示：

1. 在main()方法中，我们可以直接调用 main 方法所在类的静态方法或静态属性
2. 但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个静态成员

##### 10.3代码块

代码化块又称为**初始化块**，属于类中的成员[即是类的一部分]，类似于方法，将逻辑语句封装在方法体中，通过{}包围起来。

但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显式调用，而是加载类时，或创建对象时隐式调用。

代码：

```java
[修代码饰符]{
	代码
};
/*说明注意：
1)修饰符可选，要写的话，也只能写static
2)代码块分为两类，使用static修饰的叫静态代码块，没有static修饰的，叫普通代码块/非静态代码块
3)逻辑语句可以为任何逻辑语句(输入、输出、方法调用、循环、判断等)
4);号可以写上，也可以省略。*/
//其实代码块就相当于另一种形式的构造器(队构造器的补充机制)，可以做初始化操作，如果多个构造器中都有重复语句，可以抽取到初始化块中，提高代码的重用性
```

代码块使用注意事项和细节讨论

1）static代码块也叫静态代码块，作用就是对类进行初始化，而且它随着**类的加载**而执行，并且**只会执行一次**。如果是普通代码块，每创建一个对象，就执行。

2）类什么时候被加载	**[重要，背!]**

- 创建对象实例时(new)
- 创建子类对象实例，父类也会被加载2
- 使用类的静态成员时(静态属性，静态方法)
  案例演示: A类 extends B类 的静态块

3）普通的代码块，在创建对象实例时，会被隐式的调用。
		被创建一次，就会调用一次。
		如果只是使用类的静态成员时，普通代码块并不会执行

这里的小结：

1. static代码块是**类加载**时，执行，只会执行一次
2. 普通代码块是在创建对象时调用的，创建一次，调用一次
3. 类加载的3种情况，需要记住

4）创建一个对象时，在**一个类**调用顺序是:(**重点，难点**):

1. 调用静态代码块和静态属性初始化（注意：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用)
2. 调用普通代码块和普通属性的初始化（注意：普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义顺序调用）
3. 调用构造方法。

这里的小结：在类被加载的时候，首先挑选静态的成员按照定义顺序依次调用，在没有静态成员的时候寻找普通成员按照定义顺序调用，最后再调用构造器

5）构造器的最前面其实隐含了 super()和调用普通代码块，新写一个类演示，静态相关的代码块，属性初始化，在类加载时，就执行完毕，因此是优先于构造器和普通代码块执行的。

6）创建一个子类对象时(继承关系)，他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序如下：	父类的静态代码块和静态属性(优先级一样，按定义顺序执行)
	子类的静态代码块和静态属性(优先级一样，按定义顺序执行)
	父类的普通代码块和普通属性初始化(优先级一样，按定义顺序执行)
	父类的构造方法
	子类的普通代码块和普通属性初始化(优先级一样，按定义顺序执行)
	子类的构造方法 

7）静态代码块只能直接调用静态成员(静态属性和静态方法)，普通代码块可以调用任意成员。学习比较麻烦，工作轻松。

##### 10.4 单例设计模式

采取一定方法保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。

两种方式：**饿汉式，懒汉式**

实现步骤：

1. 构造器私有化 => 防止直接new
2. 类的内部创建对象
3. 向外暴露一个静态的公共方法

两者相比：

1. 二者最主要的区别在于创建对象的**时机**不同：饿汉式是在类加载就创建了对象实例，而懒汉式是在使用时才创建。
2. 饿汉式不存在线程安全问题，懒汉式存在线程安全问题。（学习线程后，会完善）
3. 饿汉式存在浪费资源的可能。因为如果程序员一个对象实例都没有使用，那么饿汉式创建的对象就浪费了，懒汉式是使用时才创建，就不存在这个问题。
4. 在我们javaSE标准类中，java.lang.Runtime就是经典的单例模式



##### 10.5 final关键字

在某些情况下有以下需求，就会用到final:

1. 当不希望类被继承时,可以用final修饰。
2. 当不希望父类的某个方法被子类覆盖/重写(override)时,可以用final关键字修饰。
3. 当不希望类的的某个属性的值被修改,可以用final修饰。
4. 当不希望某个局部变量被修改，可以使用final修饰。

**注意事项**

1. final修饰的属性又叫常量，一般用XX_XX_XX 来命名。
2. final修饰的属性在定义时，必须赋初值，并且以后不能再修改，赋值可以在如下位置之一[选择一个位置赋初值即可]：
   1. 定义时: 如 public final double TAX RATE=0.08;
   2. 在构造器中
   3. 在代码块中
3. 如果final修饰的属性是静态的，则初始化的位置只能是
   1. 定义时 
   2. 在静态代码块 
   3. 不能在构造器中赋值
4. final类不能继承，但是可以实例化对象。
5. 如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承。
6. 一般来说，如果一个类已经是final类了，就没有必要再将方法修饰成final方法
7. final不能修饰构造方法(即构造器)
8. final 和 static 往往搭配使用，效率更高，不会导致类加载.底层编译器做了优化处理。
9. 包装类(Integer,Double,Float,Boolean等都是final),String也是final类。



##### 10.6 抽象类

当父类的某些方法，需要声明，但是又不确定如何实现时，可以将其声明为抽象方法，那么这个类就是抽象类。

1. 用abstract 关键字来修饰一个类时，这个类就叫抽象类
   访问修饰符 abstract 类名{
   }
2. 用abstract关键字来修饰一个方法时,这个方法就是抽象方法
   访问修饰符 abstract 返回类型 方法名(参数列表)://没有方法体
3. 抽象类的价值更多作用是在于设计，是设计者设计好后，让子类继承并实现抽象类()
4. 抽象类，是考官比较爱问的知识点，在框架和设计模式使用较多

**注意事项**

1. 抽象类不能被实例化
2. 抽象类不一定要包含abstract方法。也就是说，抽象类可以没有abstract方法
3. 一旦类包含了abstract方法，则这个类必须声明为abstract
4. abstract 只能修饰类和方法，不能修饰属性和其它的。
5. 抽象类可以有任意成员[抽象类本质还是类]，比如:：非抽象方法构造器、静态属性等等
6. 抽象方法不能有主体
7. 如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类。
8. 抽象方法不能使用private、final和 static来修饰，因为这些关键字都是和重写相违背的。

##### 10.7 抽象类最佳实践-模板设计模式

抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式。

能够解决的问题：

1. 当功能内部一部分实现是确定，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。
2. 编写一个抽象父类，父类提供了多个子类的通用方法，并把一个或多个方法留给其子类实现，就是一种模板模式.



##### 10.8 接口

接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，再根据具体情况把这些方法写出来：

```java
interface 接口名{
	//属性
	//抽象方法
}
class 类名 implements 接口{
	自己属性;
	自己方法;
	必须实现的接口的抽象方法
}
//接口是更加抽象的抽象的类，抽象类里的方法可以有方法体，接口里的所有方法都没有方法体[jdk7.0]。接口体现了程序设计的多态和高内聚低偶合的设计思想。
//特别说明: Jdk8.0后接口类可以有静态方法，默认方法，也就是说接口中可以有方法的具体实现
```

注意事项：

1. 接口不能被实例化。
2. 接口中所有的方法是 public方法，接口中抽象方法，可以不用abstract 修饰。
3. 一个普通类实现接口，就必须将该接口的所有方法都实现。
4. 抽象类实现接口，可以不用实现接口的方法。
5. 一个类同时可以实现多个接口
6. 接口中的属性，只能是final的，而且是public static final修饰符。比如int a=1: 实际上是 public static final int a=1:(必须初始化)
7. 接口中属性的访问形式: 接口名.属性名
8. 接口不能继承其它的类,但是可以继承多个别的接口 [举例]
   interface A extends B,C{}
9. 接口的修饰符 只能是 public 和默认，这点和类的修饰符是一样的。



接口&继承

继承的价值主要在于：解决代码的**复用性和可维护性**
接口的价值主要在于：设计，设计好各种规范(方法)，让其它类去实现这些方法。

接口比继承更加灵活，继承是满足is - a的关系，而接口只需满足like - a的关系

接口在一定程度上实现代码解耦[即: 接口规范性+动态绑定机制]

接口存在**多态传递**现象



##### 10.9 内部类

一个类的内部又完整的嵌套了另一个类结构。被嵌套的类称为内部类(inner class),嵌套其他类的类称为外部类(outer class)。是我们类的第五大成员[思考: 类的五大成员是哪些?[属性、方法、构造器、代码块、内部类]]，内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系，注意:内部类是学习的难点，同时也是重点，后面看底层源码时，有大量的内部类.

###### 基本语法

```java
class Outer{	//外部类
	class Inner{	//内部类
	}
}
class Other{	//外部其他类
}
```

###### 分类

定义在外部类局部位置上：

1. 局部内部类（有类名）
2. 匿名内部类（没有类名，这个是重点！）

定义在外部类的成员位置上

成员内部类（没用static修饰）

静态内部类（使用static修饰）

###### 局部内部类使用

说明：局部内部类是定义在外部类的局部位置，比如方法中，并且有类名

1. 可以直接访问外部类的所有成员，包含私有的
2. 不能添加访问修饰符,因为它的地位就是一个局部变量。局部变量是不能使用修饰符的。但是可以使用final 修饰，因为局部变量也可以使用final
3. 作用域: 仅仅在定义它的方法或代码块中。
4. 局部内部类---访问---->外部类的成员[访问方式: 直接访问]
5. 外部类---访问---->局部内部类的成员
   访问方式:创建对象，再访问(注意:必须在作用域内)
6. 外部其他类---不能访问----->局部内部类(因为局部内部类地位是一个局部变量
7. 如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用 (外部类名.this.成员)去访问
   System.out.println(“外部类的n2=”+ 外部类名this.n2):

记住：

1. 局部内部类定义在方法中/代码块
2. 作用域在方法体或者代码块中
3. 本质仍然是一个类



###### 匿名内部类使用

```java
/*
(1)本质是类
(2)内部类
(3)该类没有名字
(4)同时还是一个对象
说明: 匿名内部类是定义在外部类的局部位置，比如方法中，并且没有类名
*/
//匿名内部类的基本语法：
new 类或接口(参数列表){
	类体	
};
//匿名内部类的语法比较奇特，因为匿名内部类既是一个类的定义，同时它本身也是一个对象，因此从语法上看，它既有定义类的特征，也有创建对象的特征，对前面代码分析可以看出这个特点，因此可以调用匿名内部类方法。
//可以直接访问外部类的所有成员，包含私有的
//不能添加访问修饰符,因为它的地位就是一个局部变量。
//作用域：仅仅在定义它的方法或代码块中。
//匿名内部类---访问---->外部类成员 [访问方式:直接访问]
//外部其他类---不能访问-----匿名内部类(因为 匿名内部类地位是一个局部变量)
//如果外部类和匿名内部类的成员重名时，匿名内部类访问的话，默认遵循就近原则如果想访问外部类的成员，则可以使用 (外部类名.this.成员)去访问
```

###### 成员内部类的使用

```java
//说明: 成员内部类是定义在外部类的成员位置，并且没有static修饰。
//1.可以直接访问外部类的所有成员，包含私有的

class Outer01{	//外部类
private int n1 = 10;
public String name = "张三";
class Innter01{
public void say(){
System.out.println("Outer01的n1 = " + n1 + " outer01的name = " + name );
}}}

//2.可以添加任意访问修饰符(public、protected 、默认、private),因为它的地位就是一个成员
//3.作用域和外部类的其他成员一样，为整个类体比如前面案例，在外部类的成员方法中创建成员内部类对象，再调用方法.
//4.成员内部类---访问---->外部类成员(比如:属性)[访问方式:直接访问](说明)
//5.外部类---访问------>成员内部类(说明)访问方式:创建对象，再访问
//6.外部其他类---访问---->成员内部类
//7.如果外部类和内部类的成员重名时内部类访问的话，默认遵循就近原则，如果想访问外部类的成员，则可以使用(外部类名this.成员)去访问
```

###### 静态内部类的使用

说明:静态内部类是定义在外部类的成员位置，并且有static修饰

1. 可以直接访问外部类的所有静态成员，包含私有的，但不能直接访问非静态成员
2. 可以添加任意访问修饰符(public、protected 、默认、private),因为它的地位就是一个成员。
3. 作用域 : 同其他的成员，为整个类体
4. 静态内部类---访问---->外部类(比如:静态属性)[访问方式: 直接访问所有静态成员]
5. 外部类---访问------>静态内部类 访问方式:创建对象，再访问
6. 外部其他类---访问----->静态内部类
7. 如果外部类和静态内部类的成员重名时，静态内部类访问的时，默认遵循就近原则，如果想访问外部类的成员，则可以使用 (外部类名.成员)去访问





p389

#### 第11章 枚举和注解





#### 第12章 异常-EXCEPTION

#### 第13章 常用类

#### 第14章 集合

#### 第15章 泛型

#### 第16章 项目-坦克大战-1

#### 第17章 多线程基础

#### 第18章 项目-坦克大战-2

#### 第19章 IO流

#### 第20章 项目-坦克大战-3

#### 第21章 网络编程

#### 第22章 多用户即时通信系统

#### 第23章 反射(REFLECTION)

#### 第24章 MYSQL

#### 第25章 JDBC和数据库连接池

#### 第26章 满汉楼

#### 第27章 正则表达式

#### 第28章 算法优化体验-其实周游问题

